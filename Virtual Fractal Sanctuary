<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Virtual Fractal Sanctuary v7</title>
  <style>
    body { margin:0; overflow:hidden; background:#0a0a23; }
    canvas { display:block; }
    #info{position:absolute;top:10px;left:10px;color:#fff;font:14px sans-serif;}
    #dimension{position:absolute;top:40px;left:10px;color:#fff;font:14px sans-serif;}
    #profile{position:absolute;top:70px;left:10px;color:#fff;font:14px sans-serif;}
    #messages{position:absolute;bottom:10px;right:10px;width:300px;height:150px;
              background:rgba(0,0,0,0.5);color:#fff;padding:5px;overflow-y:auto;
              font:12px sans-serif;white-space:pre-wrap;}
    #input{position:absolute;bottom:170px;right:10px;width:290px;padding:5px;font:12px sans-serif;}
    button{position:absolute;right:10px;padding:5px;background:#444;color:#fff;border:none;cursor:pointer;}
    #saveFractal{top:40px;}
    #vrButton{top:10px;}
  </style>
</head>
<body>
  <div id="info">Virtual Fractal Sanctuary v7 – Click bubbles to pop them</div>
  <div id="dimension">Density 1, Dimension 1</div>
  <div id="profile">Profile: 0/108 stages reached</div>
  <button id="vrButton">Enter VR</button>
  <button id="saveFractal">Save Image</button>
  <textarea id="messages" readonly>
Welcome to the Virtual Fractal Sanctuary!
Click the floating bubbles to pop them and experience a burst of light with ripples!
  </textarea>
  <input id="input" placeholder="Share your thoughts…" />

  <!-- three.js, controls, VRButton, Tone.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://unpkg.com/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.134.0/examples/js/webxr/VRButton.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.26/Tone.min.js"></script>

  <script>
  // — Scene & renderer —
  const scene    = new THREE.Scene();
  const camera   = new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,1000);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth,innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  // — Controls & VRButton —
  const controls = new THREE.OrbitControls(camera,renderer.domElement);
  controls.enableDamping = true;
  document.getElementById('vrButton').addEventListener('click',()=>{
    document.body.appendChild(THREE.VRButton.createButton(renderer));
  });
  camera.position.z = 20;

  // — Fractal generation —
  let fractal, cReal=-0.8, cImag=0.156, fractalScale=1;
  function generateFractal(){
    const geo = new THREE.BufferGeometry();
    const verts = [], cols = [];
    const N = 100;
    for(let x=-N; x<N; x++){
      for(let y=-N; y<N; y++){
        let zr=(x/N)*4-2, zi=(y/N)*4-2, i=0;
        for(; i<50; i++){
          const r2=zr*zr, i2=zi*zi;
          if(r2+i2>4) break;
          const tmp = r2 - i2 + cReal;
          zi = 2*zr*zi + cImag;
          zr = tmp;
        }
        if(i<50){
          const z=(i/50)*10;
          verts.push(x/10,y/10,z);
          const hue = ((i/50)*360 + performance.now()*0.01)%360;
          const col = new THREE.Color(`hsl(${hue},100%,50%)`);
          cols.push(col.r,col.g,col.b);
        }
      }
    }
    if(!verts.length){
      verts.push(0,0,0); cols.push(1,1,1);
    }
    geo.setAttribute('position',new THREE.Float32BufferAttribute(verts,3));
    geo.setAttribute('color',   new THREE.Float32BufferAttribute(cols,3));
    return new THREE.Points(geo,new THREE.PointsMaterial({
      size:0.1*fractalScale, vertexColors:true
    }));
  }

  // — Bubbles & enhanced pop effect with ripple —
  const bubbles = [];
  const bubbleColors = [0x00aaff, 0x00ffaa, 0xaa00ff, 0xffaa00, 0xff00aa]; // Blue, Green, Purple, Gold, Magenta
  function spawnBubbles(){
    for(let i=0;i<10;i++){
      const color = bubbleColors[Math.floor(Math.random() * bubbleColors.length)];
      const b = new THREE.Mesh(
        new THREE.SphereGeometry(0.3,16,16),
        new THREE.MeshBasicMaterial({color:color,transparent:true,opacity:0.7})
      );
      b.position.set((Math.random()-0.5)*20,(Math.random()-0.5)*20,(Math.random()-0.5)*20);
      b.userData.vel = new THREE.Vector3(
        (Math.random()-0.5)*0.1,
        (Math.random()-0.5)*0.1,
        (Math.random()-0.5)*0.1
      );
      scene.add(b);
      bubbles.push(b);
    }
  }
  spawnBubbles();

  function createBurstEffect(pos){
    // Light flash
    const light = new THREE.PointLight(0xffffff,1,10);
    light.position.copy(pos); scene.add(light);
    let intensity=1;
    const fade = setInterval(()=>{
      intensity -= 0.05; light.intensity=intensity;
      if(intensity<=0){ scene.remove(light); clearInterval(fade); }
    },50);

    // Spiral effect
    const spiralGeo = new THREE.BufferGeometry();
    const spiralVerts = [];
    const spiralCols = [];
    for (let i = 0; i < 100; i++) {
      const angle = (i / 100) * Math.PI * 4;
      const radius = (i / 100) * 2;
      const x = pos.x + Math.cos(angle) * radius;
      const y = pos.y + Math.sin(angle) * radius;
      const z = pos.z + (i / 100) * 2;
      spiralVerts.push(x, y, z);
      const hue = (i * 3) % 360;
      const col = new THREE.Color(`hsl(${hue}, 100%, 50%)`);
      spiralCols.push(col.r, col.g, col.b);
    }
    spiralGeo.setAttribute('position', new THREE.Float32BufferAttribute(spiralVerts, 3));
    spiralGeo.setAttribute('color', new THREE.Float32BufferAttribute(spiralCols, 3));
    const spiralMat = new THREE.PointsMaterial({ size: 0.1, vertexColors: true, transparent: true });
    const spiral = new THREE.Points(spiralGeo, spiralMat);
    scene.add(spiral);
    let spiralOpacity = 1;
    const spiralFade = setInterval(() => {
      spiralOpacity -= 0.05;
      spiral.material.opacity = spiralOpacity;
      if (spiralOpacity <= 0) {
        scene.remove(spiral);
        clearInterval(spiralFade);
      }
    }, 50);

    // Firework effect
    const fireworkGeo = new THREE.BufferGeometry();
    const fireworkVerts = [];
    const fireworkCols = [];
    for (let i = 0; i < 50; i++) {
      const angle = Math.random() * Math.PI * 2;
      const radius = Math.random() * 2;
      const x = pos.x + Math.cos(angle) * radius;
      const y = pos.y + Math.sin(angle) * radius;
      const z = pos.z + (Math.random() - 0.5) * 2;
      fireworkVerts.push(x, y, z);
      const hue = (Math.random() * 360) % 360;
      const col = new THREE.Color(`hsl(${hue}, 100%, 50%)`);
      fireworkCols.push(col.r, col.g, col.b);
    }
    fireworkGeo.setAttribute('position', new THREE.Float32BufferAttribute(fireworkVerts, 3));
    fireworkGeo.setAttribute('color', new THREE.Float32BufferAttribute(fireworkCols, 3));
    const fireworkMat = new THREE.PointsMaterial({ size: 0.2, vertexColors: true, transparent: true });
    const firework = new THREE.Points(fireworkGeo, fireworkMat);
    scene.add(firework);
    let fireworkOpacity = 1;
    const fireworkFade = setInterval(() => {
      fireworkOpacity -= 0.05;
      firework.material.opacity = fireworkOpacity;
      if (fireworkOpacity <= 0) {
        scene.remove(firework);
        clearInterval(fireworkFade);
      }
    }, 50);

    // Ripple effect (new)
    const rippleGeo = new THREE.BufferGeometry();
    const rippleVerts = [];
    const rippleCols = [];
    for (let i = 0; i < 60; i++) { // 60 particles in a circle
      const angle = (i / 60) * Math.PI * 2;
      const radius = 0.5; // Starting radius
      const x = pos.x + Math.cos(angle) * radius;
      const y = pos.y + Math.sin(angle) * radius;
      const z = pos.z;
      rippleVerts.push(x, y, z);
      const hue = (i * 6) % 360;
      const col = new THREE.Color(`hsl(${hue}, 100%, 50%)`);
      rippleCols.push(col.r, col.g, col.b);
    }
    rippleGeo.setAttribute('position', new THREE.Float32BufferAttribute(rippleVerts, 3));
    rippleGeo.setAttribute('color', new THREE.Float32BufferAttribute(rippleCols, 3));
    const rippleMat = new THREE.PointsMaterial({ size: 0.15, vertexColors: true, transparent: true });
    const ripple = new THREE.Points(rippleGeo, rippleMat);
    scene.add(ripple);
    let rippleScale = 1;
    let rippleOpacity = 1;
    const rippleFade = setInterval(() => {
      rippleScale += 0.1; // Expand the ripple
      ripple.position.set(pos.x, pos.y, pos.z); // Keep centered
      ripple.scale.set(rippleScale, rippleScale, 1); // Scale in XY plane
      rippleOpacity -= 0.05;
      ripple.material.opacity = rippleOpacity;
      if (rippleOpacity <= 0) {
        scene.remove(ripple);
        clearInterval(rippleFade);
      }
    }, 50);

    // Pop sound
    new Tone.Synth().toDestination().triggerAttackRelease("C6","16n");
  }

  // — Densities & Dimensions data —
  const densities = [];
  for (let D = 1; D <= 12; D++) {
    const arr = [];
    const narrationThemes = [
      "Peace", "Balance", "Chaos", "Awareness", "Imagination", "Compassion", "Insight", "Möbius", "Spiral of Life"
    ];
    const densityThemes = [
      "Foundation of Being",
      "Duality and Harmony",
      "Physical Manifestation",
      "Time and Perception",
      "Creative Expression",
      "Unity and Empathy",
      "Inner Knowing",
      "Infinite Cycles",
      "Cosmic Integration",
      "Transcendence",
      "Eternal Source",
      "Pure Consciousness"
    ];
    for (let d = 1; d <= 9; d++) {
      const narration = `Welcome to Density ${D}, Dimension ${d}: ${narrationThemes[d - 1]} within the ${densityThemes[D - 1]}. Feel the ${narrationThemes[d - 1].toLowerCase()} as you ascend into this layer of consciousness.`;
      arr.push({
        name: `${D}D${d}`,
        cReal: -0.8 + (D - 1) * 0.1 + (d - 1) * 0.02,
        cImag: 0.156 + (D - 1) * 0.05 + (d - 1) * 0.01,
        scale: 1 + D * 0.1 + d * 0.05,
        narration: narration
      });
    }
    densities.push(arr);
  }
  console.log(`Densities initialized: ${densities.length} densities, each with ${densities[0]?.length || 0} dimensions`);

  // — Profile & stage logic (start at D1D1) —
  let userProfile = { currentDensity: 1, currentDimension: 1, highestStage: 0 }; // Always start at D1D1
  localStorage.setItem('fractalSanctuaryProfile', JSON.stringify(userProfile)); // Reset storage
  let currentDensity   = userProfile.currentDensity;
  let currentDimension = userProfile.currentDimension;
  const profileText  = document.getElementById('profile');
  const dimensionTxt = document.getElementById('dimension');
  const messages     = document.getElementById('messages');

  function updateProfile(){
    const idx=(userProfile.currentDensity-1)*9+userProfile.currentDimension;
    userProfile.highestStage=Math.max(userProfile.highestStage,idx);
    profileText.textContent=`Profile: ${userProfile.highestStage}/108 stages reached`;
    localStorage.setItem('fractalSanctuaryProfile',JSON.stringify(userProfile));
  }
  updateProfile();

  function updateStage(){
    if(!densities.length) return;
    const D = THREE.MathUtils.clamp(currentDensity-1,0,densities.length-1);
    const dims = densities[D];
    const d = THREE.MathUtils.clamp(currentDimension-1,0,dims.length-1);
    const stage = dims[d];

    // set UI & fractal params
    dimensionTxt.textContent=`Density ${currentDensity}, Dimension ${currentDimension}`;
    cReal=stage.cReal; cImag=stage.cImag; fractalScale=stage.scale;

    // replace fractal
    if(fractal) scene.remove(fractal);
    fractal = generateFractal();
    scene.add(fractal);

    // narration & chat
    messages.value+=`Entering ${stage.name}: ${stage.narration}\n`;
    messages.scrollTop=messages.scrollHeight;
    speechSynthesis.speak(new SpeechSynthesisUtterance(stage.narration));

    // respawn bubbles
    bubbles.forEach(b=>scene.remove(b));
    bubbles.length=0;
    spawnBubbles();

    // save profile
    userProfile.currentDensity   = currentDensity;
    userProfile.currentDimension = currentDimension;
    updateProfile();

    // next stage
    currentDimension++;
    if(currentDimension>9){
      currentDimension=1;
      currentDensity++;
      if(currentDensity>12) currentDensity=1;
    }
    setTimeout(updateStage,15000);
  }

  // — Initial fractal & start —
  fractal = generateFractal();
  scene.add(fractal);
  updateStage();

  // — Raycaster for bubble pop —
  const raycaster = new THREE.Raycaster();
  const mouse     = new THREE.Vector2();
  function popBubbles(){
    raycaster.setFromCamera(mouse,camera);
    const hits = raycaster.intersectObjects(bubbles);
    if(hits.length){
      const b = hits[0].object;
      const pos = b.position.clone();
      scene.remove(b);
      bubbles.splice(bubbles.indexOf(b),1);
      createBurstEffect(pos);
      messages.value+="Bubble popped! ✨\n";
      messages.scrollTop=messages.scrollHeight;
      // spawn 1 replacement
      spawnBubbles();
    }
  }

  // desktop click
  window.addEventListener('click',e=>{
    if(!renderer.xr.isPresenting){
      mouse.x=(e.clientX/innerWidth)*2-1;
      mouse.y=-(e.clientY/innerHeight)*2+1;
      popBubbles();
    }
  });

  // VR select
  renderer.xr.getController(0).addEventListener('select',popBubbles);
  renderer.xr.getController(1).addEventListener('select',popBubbles);

  // — Chat input —
  document.getElementById('input').addEventListener('keypress',e=>{
    if(e.key==='Enter'&&e.target.value.trim()){
      messages.value+=`You: ${e.target.value}\n`;
      messages.scrollTop=messages.scrollHeight;
      setTimeout(()=>{
        messages.value+="Community: Thanks for sharing!\n";
        messages.scrollTop=messages.scrollHeight;
      },500);
      e.target.value='';
    }
  });

  // — Save fractal screenshot —
  document.getElementById('saveFractal').addEventListener('click',()=>{
    const link=document.createElement('a');
    link.download=`fractal-${currentDensity}D${currentDimension}.png`;
    link.href=renderer.domElement.toDataURL();
    link.click();
  });

  // — Animation loop —
  function animate(){
    renderer.setAnimationLoop(()=>{
      if(fractal) fractal.rotation.z += 0.001;
      bubbles.forEach(b=>{
        b.position.add(b.userData.vel);
        ['x','y','z'].forEach(ax=>{
          if(Math.abs(b.position[ax])>20) b.userData.vel[ax]*=-1;
        });
      });
      controls.update();
      renderer.render(scene,camera);
    });
  }
  animate();

  // — Resize —
  window.addEventListener('resize',()=>{
    camera.aspect=innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
  });
  </script>
</body>
</html>
